%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0

\documentclass[acmsmall,screen,review]{acmart}

\usepackage{syntax}
\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{\normalfont\itshape}

\usepackage{prftree}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{subcaption}
\usepackage{fancyvrb}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
%    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcounter{todos}
\newcommand{\TODO}[1]{{
  \stepcounter{todos}
  \begin{center}\large{\textcolor{red}{\textbf{TODO \arabic{todos}:} #1}}\end{center}
}}
\newcommand{\sorry}{\textcolor{red}{\textbf{sorry}}}

\newcommand{\todo}[1]{\stepcounter{todos} \textcolor{red}{TODO \arabic{todos}: #1}}

% Math fonts
\newcommand{\mc}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\mb}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\ms}[1]{\ensuremath{\mathsf{#1}}}

% Math
\newcommand{\nats}{\mathbb{N}}

% Syntax atoms
\newcommand{\lbl}[1]{{`#1}}
\newcommand{\lto}{\Rightarrow}
\newcommand{\linl}[1]{\ms{inl}\;{#1}}
\newcommand{\linr}[1]{\ms{inr}\;{#1}}
\newcommand{\labort}[1]{\ms{abort}\;{#1}}

% Syntax
\newcommand{\letexpr}[3]{\ensuremath{\ms{let}\;#1 = #2;\;#3}}
\newcommand{\caseexpr}[5]{\ms{case}\;#1\;\{\linl{#2} \lto #3, \linr{#4} \lto #5\}}
\newcommand{\letstmt}[3]{\ensuremath{\ms{let}\;#1 = #2; #3}}
\newcommand{\brb}[2]{\ms{br}\;#1\;#2}
\newcommand{\lbrb}[2]{\brb{\lbl{#1}}{#2}}
\newcommand{\ite}[3]{\ms{if}\;#1\;\{#2\}\;\ms{else}\;\{#3\}}
\newcommand{\casestmt}[5]{\ms{case}\;#1\;\{\linl{#2} \lto #3, \linr{#4} \lto #5\}}
\newcommand{\where}[2]{#1\;\ms{where}\;\{#2\}}
\newcommand{\wbranch}[3]{#1(#2) \lto #3}
\newcommand{\lwbranch}[3]{\wbranch{\lbl{#1}}{#2}{#3}}

% Judgements
\newcommand{\cwk}[2]{#1 \mapsto #2}
\newcommand{\lwk}[2]{#1 \rightsquigarrow #2}
\newcommand{\thyp}[3]{#1 : {#2}^{#3}}
\newcommand{\bhyp}[2]{#1 : #2}
\newcommand{\lhyp}[2]{#1(#2)}
\newcommand{\llhyp}[2]{\lhyp{\lbl{#1}}{#2}}
\newcommand{\rle}[1]{{\scriptsize\textsf{#1}}}
\newcommand{\hasty}[4]{#1 \vdash_{#2} #3: {#4}}
\newcommand{\haslb}[3]{#1 \vdash #2 \rhd #3}
\newcommand{\isop}[4]{#1: #2 \to_{#4} #3}
\newcommand{\issubst}[3]{#1: #2 \mapsto #3}
\newcommand{\lbsubst}[3]{#1: #2 \rightsquigarrow #3}
\newcommand{\teqv}{\approx}
\newcommand{\tmeq}[5]{#1 \vdash_{#2} #3 \teqv #4 : {#5}}
\newcommand{\lbeq}[4]{#1 \vdash #2 \teqv #3 : {#4}}

% Denotational semantics
\newcommand{\dnt}[1]{\llbracket{#1}\rrbracket}
\newcommand{\ednt}[1]{\left\llbracket{#1}\right\rrbracket}

% Branding
\newcommand{\isotopessa}{\(\lambda_{\ms{SSA}}\)}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2024}
\acmYear{2024}
\acmDOI{XXXXXXX.XXXXXXX}

%%
%% These commands are for a JOURNAL article.
% \acmJournal{JACM}
% \acmVolume{37}
% \acmNumber{4}
% \acmArticle{111}
% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

\begin{document}

\title{The Denotational Semantics of SSA}

\author{Jad Ghalayini}
\email{jeg74@cl.cam.ac.uk}
\orcid{0000-0002-6905-1303}

\author{Neel Krishnaswami}
\email{nk480@cl.cam.ac.uk}
\orcid{0000-0003-2838-5865}

\begin{abstract}
  ...
\end{abstract}

\begin{CCSXML}
  <ccs2012>
  <concept>
  <concept_id>10003752.10010124.10010131.10010133</concept_id>
  <concept_desc>Theory of computation~Denotational semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010131.10010137</concept_id>
  <concept_desc>Theory of computation~Categorical semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10003790.10011740</concept_id>
  <concept_desc>Theory of computation~Type theory</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Denotational semantics}
\ccsdesc[500]{Theory of computation~Categorical semantics}
\ccsdesc[500]{Theory of computation~Type theory}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{SSA, Categorical Semantics, Elgot Structure, Effectful Category}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

\maketitle

\section{Introduction}

Static single assignment form, or SSA form, has been the dominant
compiler intermediate representation since its introduction by
\citet{ssa-intro} in the later 1980s. Every major compiler -- GCC, Clang,
MLIR, Cranelift -- uses this representation, because it makes many
optimizations much easier to do than traditional 3-address code IRs.

The key idea behind SSA is to adapt an idea from functional
programming: namely, every variable is defined only once. This means
that substitution is unconditionally valid, without first requiring a
dataflow analysis to compute where definitions reach. Unlike in
functional programming, though, scoping of definitions in SSA is
traditionally not lexical. Instead, scoping is determined by
\emph{dominance}: every variable occurence must be dominated by a
single assignment in the control flow graph.

The semantics of SSA has traditionally been handled quite informally,
because conceptually, it is a simple first-order imperative
programming language. As a result, whether a rewrite is sound or
not is usually obvious, without having to do a complex correctness
argument.

Unfortunately, computers are no longer as simple as they were in the
late 1980s. Modern computers are typically multicore, and feature many
levels of caching, and as a result the semantics of memory is no
longer correctly modelled as a big array of bytes. Finding good
semantics for modern weak memory systems remains an ongoing challenge.

As a result, it is not correct to justify compiler optimizations in
terms of a simple imperative model, and it is an open question which
equations should hold of an SSA program. This is a particularly
fraught question, because it is also unclear which equations weak
memory models should satisfy.

What we would like to know which equations any SSA representation
should satisfy. This would let us establish a contract between
compiler writers and hardware designers. The compiler writers could
rely upon the equational theory of SSA when justifying optimizations,
without needing to know all the details of the memory model at all
times.  Conversely, memory models could be validated by seeing if they
satisfy the equations of SSA, without needing to study every possible
compiler optimization.

Concretely, our contributions are as follows: 

\begin{itemize}
\item First, we give a type-theoretic presentation of SSA, with both typing rules and an equational
  theory for well-typed terms. We also prove the correctness of suitable substitution properties for
  this calculus. 
  
\item Next, we give a categorical semantics for this type theory, in terms of distributive Elgot
  categories. We show that any denotational model with this categorical structure is also a model of
  SSA. This shows that all of the equations we give are sound with respect to the categorical
  structure. 

\item We also show that syntax quotiented by the equational theory yields the initial distributive
  Elgot category. This establishes that our set of syntactic equations is complete, and that there
  are no equations which the denotational semantics validates, but which cannot be proved
  syntactically. 

\item We show that this denotational axiomatization is useful in practice, by giving a variety of
  concrete models, including a model of TSO weak memory based on~\cite{sparky}. This demonstrates
  that it is possible to give realistic weak memory models which do not disturb the structure of SSA
  in fundamental ways.

\item Finally, we have substantially mechanized our proofs using the Lean 4 proof assistant. We have
  mechanized proofs of substitution for our type theory, as well as proofs that the syntax forms the
  initial model, and that the SPARC TSO semantics forms a valid model of SSA. The denotational
  semantics and its proof of the soundness of substitution are done on paper. 

\end{itemize}

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\clearpage 

\appendix

\section{Syntax and Typing Rules}

\begin{figure}[H]
  \begin{center}
    \begin{grammar}
      <\(A, B, C\)> ::= 
      \(X\)
      \;|\; \(A \otimes B\)
      \;|\; \(\mathbf{1}\)
      \;|\; \(A + B\)
      \;|\; \(\mathbf{0}\)

      <\(a, b, c, e\)> ::= \(x\) 
      \;|\;  \(f\;a\)
      \;|\; \(\letexpr{x}{a}{e}\)
      \alt  \(()\)
      \;|\; \((a, b)\)
      \;|\; \(\letexpr{(x, y)}{a}{e}\)
      \alt  \(\linl{a}\) 
      \;|\; \(\linr{a}\)
      \;|\; \(\labort{a}\)
      \;|\; \(\caseexpr{e}{x}{s}{y}{t}\)
      
      <\(s, t\)> ::= \(\lbrb{\ell}{a}\) 
      \alt  \(\letstmt{x}{a}{t}\)
      \;|\; \(\letstmt{(x, y)}{a}{t}\)
      \;|\; \(\casestmt{e}{x}{s}{y}{t}\)
      \alt  \(\where{t}{(\lwbranch{\ell_i}{x_i: A_i}{t_i},)_i}\)

      <\(\Gamma\)> ::= \(\cdot\) \;|\; \(\Gamma, \thyp{x}{A}{\epsilon}\)

      <\(\ms{L}\)> ::= \(\cdot\) \;|\; \(\ms{L}, \llhyp{\ell}{A}\)
    \end{grammar}
  \end{center}
  \caption{Grammar for \isotopessa, parametrized over a set of instructions \(f \in \mc{I}\)}
  \Description{Grammar for isotope-SSA}
  \label{fig:ssa-grammar}
\end{figure}

\begin{figure}[H]
  \begin{gather*}
    \prftree[r]{\rle{var}}{\Gamma\;x \leq (A, \epsilon)}{\hasty{\Gamma}{\epsilon}{x}{A}} \qquad
    \prftree[r]{\rle{op}}{\isop{f}{A}{B}{\epsilon}}{\hasty{\Gamma}{\epsilon}{a}{A}}
      {\hasty{\Gamma}{\epsilon}{f\;a}{B}} \qquad
    \prftree[r]{\rle{let$_1$}}
      {\hasty{\Gamma}{\epsilon}{a}{A}}
      {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
      {\hasty{\Gamma}{\epsilon}{\letexpr{x}{a}{b}}{B}} \\
    \prftree[r]{\rle{unit}}{\hasty{\Gamma}{\epsilon}{()}{\mb{1}}} \qquad
    \prftree[r]{\rle{pair}}{\hasty{\Gamma}{\epsilon}{a}{A}}{\hasty{\Gamma}{\epsilon}{b}{B}}
      {\hasty{\Gamma}{\epsilon}{(A, B)}{A \otimes B}} \\
    \prftree[r]{\rle{let$_2$}}
      {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
      {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
      {\hasty{\Gamma}{\epsilon}{\letexpr{(x, y)}{e}{c}}{C}} \\
    \prftree[r]{\rle{inl}}{\hasty{\Gamma}{\epsilon}{a}{A}}
      {\hasty{\Gamma}{\epsilon}{\linl{a}}{A + B}} \qquad
    \prftree[r]{\rle{inr}}{\hasty{\Gamma}{\epsilon}{b}{B}}
      {\hasty{\Gamma}{\epsilon}{\linr{b}}{A + B}} \qquad
    \prftree[r]{\rle{abort}}{\hasty{\Gamma}{\epsilon}{a}{\mb{0}}}
      {\hasty{\Gamma}{\epsilon}{\labort{a}}{A}} \\
    \prftree[r]{\rle{case}}
      {\hasty{\Gamma}{\epsilon}{e}{A + B}}
      {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{C}}
      {\hasty{\Gamma, \bhyp{y}{A}}{\epsilon}{b}{C}}
      {\hasty{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{C}}
  \end{gather*}
  \caption{Rules for typing \isotopessa terms}
  \Description{Rules for typing isotope-SSA terms}
  \label{fig:ssa-term-rules}
\end{figure}

\begin{figure}[H]
  \begin{gather*}
    \prftree[r]{\rle{br}}{\hasty{\Gamma}{\bot}{a}{A}}{\ms{L}\;\lbl{\ell} = A}
      {\haslb{\Gamma}{\lbrb{\ell}{a}}{\ms{L}}} \qquad
    \prftree[r]{\rle{let$_1$-r}}
      {\hasty{\Gamma}{\epsilon}{a}{A}}
      {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
      {\haslb{\Gamma}{\letstmt{x}{a}{r}}{\ms{L}}} \\
    \prftree[r]{\rle{let$_2$-r}}
      {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
      {\haslb{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{r}{\ms{L}}}
      {\haslb{\Gamma}{\letstmt{(x, y)}{e}{r}}{\ms{L}}} \\
    \prftree[r]{\rle{case-r}}
      {\hasty{\Gamma}{\epsilon}{e}{A + B}}
      {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
      {\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}}}
      {\haslb{\Gamma}{\casestmt{e}{x}{r}{y}{s}}{\ms{L}}} \\
    \prftree[r]{\rle{cfg}}
      {\haslb{\Gamma}{r}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
      {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\haslb{\Gamma}{\where{r}{(\lwbranch{\ell_i}{x_i: A_i}{t_i},)_i}}{\ms{L}}}
  \end{gather*}
  \caption{Rules for typing \isotopessa regions}
  \Description{Rules for typing isotope-SSA regions}
  \label{fig:ssa-reg-rules}
\end{figure}

\begin{figure}[H]
  \TODO{this}
  \caption{Rules for typing \isotopessa substitutions}
  \Description{Rules for typing isotope-SSA substitutions}
  \label{fig:ssa-vsubst-rules}
\end{figure}

\begin{figure}[H]
  \TODO{this}
  \caption{Rules for typing \isotopessa label-substitutions}
  \Description{Rules for typing isotope-SSA label-substitutions}
  \label{fig:ssa-lsubst-rules}
\end{figure}

\begin{figure}[H]
  \TODO{this}
  \caption{Syntax and typing for \isotopessa composition}
  \Description{Syntax and typing for isotope-SSA composition}
  \label{fig:ssa-compose}
\end{figure}

\section{Denotational Semantics}


\begin{figure}[H]
  \TODO{this}
  \caption{Denotational semantics for \isotopessa types and contexts}
  \Description{Denotational semantics for isotope-SSA types and contexts}
  \label{fig:ssa-ty-sem}
\end{figure}

\begin{figure}[H]
  \begin{equation*}
    \boxed{\dnt{\hasty{\Gamma}{\epsilon}{a}{A}} : \dnt{\Gamma} \to_\epsilon \dnt{A}}
  \end{equation*}
  \TODO{this}
  \caption{Denotational semantics for \isotopessa terms}
  \Description{Denotational semantics for isotope-SSA terms}
  \label{fig:ssa-term-sem}
\end{figure}

\begin{figure}[H]
  \begin{equation*}
    \boxed{\dnt{\haslb{\Gamma}{r}{\ms{L}}} : \dnt{\Gamma} \to \dnt{\ms{L}}}
  \end{equation*}
  \TODO{this}
  \caption{Denotational semantics for \isotopessa regions}
  \Description{Denotational semantics for isotope-SSA regions}
  \label{fig:ssa-reg-sem}
\end{figure}

\begin{figure}[H]
  \begin{equation*}
    \boxed{\dnt{\issubst{\gamma}{\Gamma}{\Delta}} 
      : \dnt{\Gamma} \to_{\epsilon_\Delta} \dnt{\Delta}}
  \end{equation*}
  \TODO{this}
  \caption{Denotational semantics for \isotopessa substitutions}
  \Description{Denotational semantics for isotope-SSA substitutions}
  \label{fig:ssa-vsubst-sem}
\end{figure}

\begin{figure}[H]
  \begin{equation*}
    \boxed{\dnt{\lbsubst{\kappa}{\ms{L}}{\ms{K}}} 
      : \dnt{\ms{L}} \to \dnt{\ms{K}}}
  \end{equation*}
  \TODO{this}
  \caption{Denotational semantics for \isotopessa label-substitutions}
  \Description{Denotational semantics for isotope-SSA label-substitutions}
  \label{fig:ssa-lsubst-sem}
\end{figure}

\section{Equational Theory}

\subsection{Terms}

\TODO{write nicer fused version?}

\TODO{\textit{formalize} nicer fused version?}

\begin{gather*}
  \prftree[r]{\rle{refl}}{\hasty{\Gamma}{\epsilon}{a}{A}}{\tmeq{\Gamma}{\epsilon}{a}{a}{A}} \qquad
  \prftree[r]{\rle{trans}}
    {\tmeq{\Gamma}{\epsilon}{a}{b}{A}}
    {\tmeq{\Gamma}{\epsilon}{b}{c}{A}} 
    {\tmeq{\Gamma}{\epsilon}{a}{c}{A}} \qquad
  \prftree[r]{\rle{symm}}
    {\tmeq{\Gamma}{\epsilon}{a}{b}{A}}
    {\tmeq{\Gamma}{\epsilon}{b}{a}{A}}
  \\
  \prftree[r]{\rle{let$_1$-bind}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{A}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{x}{a}{b}}{\letexpr{x}{a'}{b}}{B}} 
  \\
  \prftree[r]{\rle{let$_1$-bound}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\tmeq{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{b'}{B}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{x}{a}{b}}{\letexpr{x}{a}{b'}}{B}}
  \\
  \prftree[r]{\rle{pair-l}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{A}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\tmeq{\Gamma}{\epsilon}{(a, b)}{(a', b)}{A \otimes B}} \qquad
  \prftree[r]{\rle{pair-r}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\tmeq{\Gamma}{\epsilon}{b}{b'}{B}}
    {\tmeq{\Gamma}{\epsilon}{(a, b)}{(a, b')}{A \otimes B}}
  \\
  \prftree[r]{\rle{let$_2$-bind}}
    {\tmeq{\Gamma}{\epsilon}{e}{e'}{A \otimes B}}
    {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{(x, y)}{e}{c}}{\letexpr{(x, y)}{e'}{c}}{C}}
  \\
  \prftree[r]{\rle{let$_2$-bound}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\tmeq{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{c'}{C}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{(x, y)}{e}{c}}{\letexpr{(x, y)}{e}{c'}}{C}}
  \\
  \prftree[r]{\rle{inl}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{A}}
    {\tmeq{\Gamma}{\epsilon}{\linl{a}}{\linl{a'}}{A + B}} \qquad
  \prftree[r]{\rle{inr}}
    {\tmeq{\Gamma}{\epsilon}{b}{b'}{B}}
    {\tmeq{\Gamma}{\epsilon}{\linr{b}}{\linr{b'}}{A + B}} \qquad
  \\
  \prftree[r]{\rle{abort}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{\mb{0}}}
    {\tmeq{\Gamma}{\epsilon}{\labort{a}}{\labort{a'}}{A}}
  \\
  \prftree[r]{\rle{case-d}}
    {\tmeq{\Gamma}{\epsilon}{e}{e'}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{b}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{\caseexpr{e'}{x}{a}{y}{b}}{C}}
  \\
  \prftree[r]{\rle{case-l}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\tmeq{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{a'}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{b}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{\caseexpr{e'}{x}{a'}{y}{b}}{C}}
  \\
  \prftree[r]{\rle{case-r}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{C}}
    {\tmeq{\Gamma, \bhyp{y}{B}}{\epsilon}{b}{b'}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{\caseexpr{e'}{x}{a}{y}{b'}}{C}}
\end{gather*}


\begin{gather*}
  \prftree[r]{\rle{let$_1$-$\beta$}}
    {\hasty{\Gamma}{\bot}{a}{A}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{x}{a}{b}}{[b/x]a}{B}}
  \qquad
  \prftree[r]{\rle{let$_1$-$\eta$}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{x}{a}{x}}{a}{A}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_1$-op}}
    {\isop{f}{A}{B}{\epsilon}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{y}{f\;a}{c}}{\letexpr{x}{a}{\letexpr{f\;x}{y}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-let$_1$}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}
      {\letexpr{y}{(\letexpr{x}{a}{b})}{c}}
      {\letexpr{x}{a}{\letexpr{y}{b}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-let$_2$}}
    {\hasty{\Gamma}{\epsilon}{e}{A \times B}}
    {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{C}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{z}{C}}{\epsilon}{d}{D}}
    {\tmeq{\Gamma}{\epsilon}
      {\letexpr{z}{(\letexpr{(x, y)}{e}{c})}{d}}
      {\letexpr{(x, y)}{e}{\letexpr{z}{c}{d}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-inl}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{C}}{\epsilon}{d}{D}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{y}{\linl{a}}{c}}{\letexpr{x}{a}{\letexpr{\linl{x}}{y}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-inr}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{C}}{\epsilon}{d}{D}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{y}{\linr{b}}{c}}{\letexpr{x}{b}{\letexpr{\linr{x}}{y}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-abort}}
    {\hasty{\Gamma}{\epsilon}{a}{\mb{0}}}
    {\hasty{\Gamma, \bhyp{y}{A}}{\epsilon}{b}{B}}
    {\tmeq{\Gamma}{\epsilon}
      {\letexpr{y}{\labort{b}}{b}}
      {\letexpr{x}{a}{\letexpr{y}{\labort{x}}{b}}}{B}}
  \\
  \prftree[r]{\rle{let$_1$-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{b}{C}}
    {\hasty{\Gamma, \bhyp{z}{C}}{\epsilon}{d}{D}}
    { 
      \prfStackPremises
      {\Gamma \vdash_\epsilon \letexpr{z}{(\caseexpr{e}{x}{a}{y}{b})}{d}}
      {\hspace{6em} \teqv \caseexpr{e}{x}{\letexpr{z}{a}{d}}{\letexpr{z}{b}{d}}{b} : D}
    }
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_2$-$\eta$}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{(x, y)}{e}{(x, y)}}{e}{A \otimes B}} 
  \\
  \prftree[r]{\rle{let$_2$-pair}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{(x, y)}{(a, b)}{c}}{\letexpr{x}{a}{\letexpr{y}{b}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_2$-bind}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}
      {\letexpr{(x, y)}{e}{c}}
      {\letexpr{z}{e}{\letexpr{z}{e}{c}}}{C}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{case-inl}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{d}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{\linl{a}}{x}{c}{y}{d}}{\letexpr{x}{a}{c}}{C}}
  \\
  \prftree[r]{\rle{case-inr}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{d}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{\linr{b}}{x}{c}{y}{d}}{\letexpr{y}{b}{d}}{C}}
  \\
  \prftree[r]{\rle{case-$\eta$}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{\linl{x}}{y}{\linr{y}}}{e}{A + B}}
  \\
  \prftree[r]{\rle{case-bind}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{d}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{c}{y}{d}}{\letexpr{z}{e}{\caseexpr{z}{x}{c}{y}{d}}}{C}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_1$-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{c}{C}}
    {
      \prfStackPremises
      {\hasty{\Gamma, \bhyp{x}{A + B}, \bhyp{y}{C}, \bhyp{z}{A}}{\epsilon}{d}{D}}
      {\hasty{\Gamma, \bhyp{x}{A + B}, \bhyp{y}{C}, \bhyp{z'}{B}}{\epsilon}{d'}{D}}
    }
    {
      \prfStackPremises
      {\Gamma \vdash_\epsilon \letexpr{x}{a}{\letexpr{y}{c}{\caseexpr{x}{z}{d}{z'}{d'}}}}
      {\hspace{6em} \teqv \letexpr{x}{a}{\caseexpr{x}{z}{\letexpr{y}{c}{d}}{z'}{\letexpr{y}{c}{d'}}} 
      : D}
    }
  \\
  \prftree[r]{\rle{let$_2$-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{c}{C \otimes D}}
    {
      \prfStackPremises
      {\hasty{\Gamma, \bhyp{x}{A + B}, \bhyp{y}{C}, \bhyp{z}{D}, \bhyp{w}{A}}{\epsilon}{e}{E}}
      {\hasty{\Gamma, \bhyp{x}{A + B}, \bhyp{y}{C}, \bhyp{z}{D}, \bhyp{w'}{B}}{\epsilon}{e'}{E}}
    }
    {
      \prfStackPremises
      {\Gamma \vdash_\epsilon \letexpr{x}{a}{\letexpr{(y, z)}{c}{\caseexpr{x}{w}{e}{w'}{e'}}}}
      {\hspace{5em} \teqv \letexpr{x}{a}
        {\caseexpr{x}
          {w}{\letexpr{(y, z)}{c}{e}}
          {w'}{\letexpr{(y, z)}{c}{e'}}} 
      : E}
    }
  \\
  \prftree[r]{\rle{case-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A_1 + A_2}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{b}{B_1 + B_2}}
    {
      \forall i j.
      \hasty{\Gamma, \bhyp{x}{A_1 + A_2}, \bhyp{y_i}{B_i}, \bhyp{z_j}{A_j}}{\epsilon}
            {c_{ij}}{C}
    }
    {
      \prfStackPremises
      {\Gamma \vdash_\epsilon 
        \ms{let}\;x = a;
        \ms{case}\;b\;\{\ms{inl}\;y_1 \Rightarrow \caseexpr{x}{z_1}{e_{11}}{z_2}{e_{12}}
      }
      {
        \hspace{10em} \ms{inr}\;y_2 \Rightarrow \caseexpr{x}{z_1}{e_{21}}{z_2}{e_{22}} \}
      }
      {\hspace{1.3em} \teqv
        \ms{let}\;x = a;
        \ms{case}\;x\;\{\ms{inl}\;z_1 \Rightarrow \caseexpr{b}{y_1}{e_{11}}{y_2}{e_{21}}
      }
      {
        \hspace{10em} \ms{inr}\;z_2 \Rightarrow \caseexpr{b}{y_1}{e_{12}}{y_2}{e_{22}} \}
      }
    }
  \\
  \prftree[r]{\rle{op-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\isop{f}{C}{D}{\epsilon}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c'}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{f\;c}{y}{f\;c'}}{f\;\caseexpr{e}{x}{c}{y}{c'}}{D}}
  \\
  \prftree[r]{\rle{inl-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c'}{C}}
    {\tmeq{\Gamma}{\epsilon}
      {\caseexpr{e}{x}{\linl{c}}{y}{\linl{c'}}}
      {\linl{\caseexpr{e}{x}{c}{y}{c'}}}
      {C + D}}
  \\
  \prftree[r]{\rle{inr-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{d}{D}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{d'}{D}}
    {\tmeq{\Gamma}{\epsilon}
      {\caseexpr{e}{x}{\linr{d}}{y}{\linr{d'}}}
      {\linr{\caseexpr{e}{x}{d}{y}{d'}}}
      {C + D}}
  \\
  \prftree[r]{\rle{abort-case}}
  {\hasty{\Gamma}{\epsilon}{e}{A + B}}
  {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{\mb{0}}}
  {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c'}{\mb{0}}}
  {
    \prfStackPremises
    {\Gamma \vdash_\epsilon \caseexpr{e}{x}{\labort{c}}{y}{\labort{c'}}}
    {\approx \labort{\caseexpr{e}{x}{c}{y}{c'}} : C}
  }
  \\
  \prftree[r]{\rle{pair-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A_1 + A_2}}
    {\forall i, \hasty{\Gamma, \bhyp{x_i}{A_i}}{\epsilon}{b_{ij}}{B_j}}
    {
      \prfStackPremises
      {\Gamma \vdash_\epsilon \caseexpr{e}{x}{(b_{11}, b_{12})}{y}{(b_{21}, b_{22})}}
      {\approx (\caseexpr{e}{x}{b_{11}}{y}{b_{21}}, \caseexpr{e}{x}{b_{12}}{y}{b_{22}}) 
      : B_1 \otimes B_2}
    }
  \\
  \prftree[r]{\rle{case$_0$}}
    {\hasty{\Gamma}{\epsilon}{e}{A_1 + A_2}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{a}}{a}{A}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{initial}} 
    {\hasty{\Gamma}{\bot}{a}{A}}
    {\hasty{\Gamma}{\bot}{a'}{A}}
    {\exists x, \Gamma\;x = \mb{0}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{A}}
    \qquad
  \prftree[r]{\rle{terminal}}
    {\hasty{\Gamma}{\bot}{a}{\mb{1}}}
    {\hasty{\Gamma}{\bot}{a'}{\mb{1}}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{\mb{1}}}
\end{gather*}

\TODO{soundness of term equational theory (diagrams?)}

\TODO{notes on completeness? derivable equations?}

\subsection{Regions}

\begin{gather*}
  \prftree[r]{\rle{refl}}{\haslb{\Gamma}{r}{\ms{L}}}{\lbeq{\Gamma}{r}{r}{\ms{L}}} \qquad
  \prftree[r]{\rle{trans}}{\lbeq{\Gamma}{r}{s}{\ms{L}}}{\lbeq{\Gamma}{s}{t}{\ms{L}}}
    {\lbeq{\Gamma}{r}{t}{\ms{L}}} \qquad
  \prftree[r]{\rle{symm}}{\lbeq{\Gamma}{r}{s}{\ms{L}}}{\lbeq{\Gamma}{s}{r}{\ms{L}}}
  \\
  \prftree[r]{\rle{case-left}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\lbeq{\Gamma, \bhyp{x}{A}}{r}{r'}{\ms{L}}}
    {\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}}}
    {\lbeq{\Gamma}{\caseexpr{e}{x}{r}{y}{s}}{\caseexpr{e}{x}{r'}{y}{s}}{\ms{L}}}
  \\
  \prftree[r]{\rle{case-right}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\lbeq{\Gamma, \bhyp{y}{B}}{s}{s'}{\ms{L}}}
    {\lbeq{\Gamma}{\caseexpr{e}{x}{r}{y}{s}}{\caseexpr{e}{x}{r}{y}{s'}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let}$_1$}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\lbeq{\Gamma, \bhyp{x}{A}}{r}{r'}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{x}{a}{r}}{\letstmt{x}{a}{r'}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let}$_2$}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\lbeq{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{r}{r'}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{(x, y)}{e}{r}}{\letstmt{(x, y)}{e}{r'}}{\ms{L}}}
  \\
  \prftree[r]{\rle{cfg-entry}}
    {\lbeq{\Gamma}{r}{r'}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
    {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
    {\lbeq{\Gamma}
      {\where{r}{(\lwbranch{\ell_i}{x_i: A_i}{t_i},)_i}}
      {\where{r'}{(\lwbranch{\ell_i}{x_i: A_i}{t_i},)_i}}
      {\ms{L}}
    }
  \\
  \prftree[r]{\rle{cfg-block}}
    {\haslb{\Gamma}{r}{\ms{L}}}
    {\forall i. \lbeq{\Gamma, \bhyp{x_i}{A_i}}{t_i}{t_i'}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
    {\lbeq{\Gamma}
      {\where{r}{(\lwbranch{\ell_i}{x_i: A_i}{t_i},)_i}}
      {\where{r'}{(\lwbranch{\ell_i}{x_i: A_i}{t_i'},)_i}}
      {\ms{L}}
    }
\end{gather*}

\TODO{let1-beta, let1-equiv}

\TODO{let1 theory}

\TODO{let2 theory}

\TODO{case theory}

\TODO{cfg theory}

\TODO{uniformity, codiagonal, ucfg}

\TODO{soundness of region equational theory (diagrams?)}

\TODO{notes on completeness? derivable equations?}

\section{Normalization}

\TODO{to Expr...}

\TODO{to BBRegion...}

\TODO{to TRegion ...}

\TODO{to ContRegion ...}

\section{Böhm–Jacopini}

\TODO{this...}

\end{document}
\endinput
